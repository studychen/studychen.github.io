<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>经典排序算法总结--冒泡、快排、插入、希尔、归并、选择 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言互联网面试，排序是经典问题，总结几种经典排序代码，方便后期查阅。
本文链接 http://www.alijava.com/sort-summary/    转载请注明出处。
如何测试编写的排序代码? 可以利用在线编程OJ系统 ，比如牛客网的http://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef
冒泡排序">
<meta property="og:type" content="article">
<meta property="og:title" content="经典排序算法总结--冒泡、快排、插入、希尔、归并、选择">
<meta property="og:url" content="http://yoursite.com/2016/10/02/sort-summary/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言互联网面试，排序是经典问题，总结几种经典排序代码，方便后期查阅。
本文链接 http://www.alijava.com/sort-summary/    转载请注明出处。
如何测试编写的排序代码? 可以利用在线编程OJ系统 ，比如牛客网的http://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef
冒泡排序">
<meta property="og:updated_time" content="2017-02-09T12:48:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="经典排序算法总结--冒泡、快排、插入、希尔、归并、选择">
<meta name="twitter:description" content="前言互联网面试，排序是经典问题，总结几种经典排序代码，方便后期查阅。
本文链接 http://www.alijava.com/sort-summary/    转载请注明出处。
如何测试编写的排序代码? 可以利用在线编程OJ系统 ，比如牛客网的http://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef
冒泡排序">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-sort-summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/02/sort-summary/" class="article-date">
  <time datetime="2016-10-02T01:52:40.000Z" itemprop="datePublished">2016-10-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      经典排序算法总结--冒泡、快排、插入、希尔、归并、选择
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网面试，排序是经典问题，总结几种经典排序代码，方便后期查阅。</p>
<p>本文链接 <a href="http://www.alijava.com/sort-summary/" target="_blank" rel="external">http://www.alijava.com/sort-summary/</a>    转载请注明出处。</p>
<p>如何测试编写的排序代码? 可以利用在线编程OJ系统 ，比如牛客网的<br><a href="http://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef" target="_blank" rel="external">http://www.nowcoder.com/questionTerminal/508f66c6c93d4191ab25151066cb50ef</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>对纵向排列的关键字序列，按照自下而上的扫描方向对两两相邻的关键字进行比较，<br>若为逆序(k_j &lt; k_j-1 )，则将两个记录交换位置；<br>重复上述扫描排序过程，直至没有记录需要交换为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	<span class="keyword">boolean</span> swap = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123; <span class="comment">//最多进行 n-1 趟</span></div><div class="line">		swap = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">//从下往上扫描</span></div><div class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</div><div class="line">				swap(arr, j, j - <span class="number">1</span>);</div><div class="line">				swap = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!swap) &#123;</div><div class="line">			<span class="keyword">break</span>; <span class="comment">// 未发生交换，终止算法</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序的优化：<br>至多需要 n-1 趟扫描，如果在某趟扫描后，待排序记录已是有序，可以在此趟扫描后终止。<br>可引入布尔量<code>swap</code>，每次扫描前值为<code>false</code>，若排序过程中发生了交换，置为<code>true</code>。<br>在一趟扫描后，如果<code>swap</code>仍为<code>false</code>，表示本次未曾交换记录，可以终止算法。</p>
<h3 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> one, <span class="keyword">int</span> two)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = arr[one];</div><div class="line">	arr[one] = arr[two];</div><div class="line">	arr[two] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>通过一趟排序将记录序列分成两个子序列，<br>再分别对这两个子序列进行排序以达到整个序列有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 排序范围 [start, end], 包含 end </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">		<span class="keyword">int</span> p = partition(arr, start, end);</div><div class="line">		quickSort(arr, start, p - <span class="number">1</span>);</div><div class="line">		quickSort(arr, p + <span class="number">1</span>, end);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一次划分代码，返回被划分后的基准位置</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> pivot = arr[left];</div><div class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot)</div><div class="line">			right--;</div><div class="line">		<span class="keyword">if</span> (left &lt; right)</div><div class="line">			arr[left++] = arr[right];</div><div class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)</div><div class="line">			left++;</div><div class="line">		<span class="keyword">if</span> (left &lt; right)</div><div class="line">			arr[right--] = arr[left];</div><div class="line">	&#125;</div><div class="line">	arr[left] = pivot;</div><div class="line">	<span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序的优化：<br>基准的选择影响快速排序的性能，最理想的情况是：选择的基准恰好能把待排序序列分成两个等长的子序列。</p>
<p>上文选择基准是固定使用序列的第1个元素，改进思路是：使用左端、右端和中间位置上的三个元素的<strong>中位数</strong>作为基准。</p>
<h2 id="非递归实现-快速排序"><a href="#非递归实现-快速排序" class="headerlink" title="非递归实现 快速排序"></a>非递归实现 快速排序</h2><p>思路就是用<strong>栈</strong>模拟递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>]; <span class="comment">// 数组模拟栈</span></div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	stack[len++] = start; <span class="comment">// 入栈</span></div><div class="line">	stack[len++] = end;</div><div class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// 栈中还有元素</span></div><div class="line">		<span class="keyword">int</span> right = stack[--len]; <span class="comment">// 注意是 --len</span></div><div class="line">		<span class="keyword">int</span> left = stack[--len];</div><div class="line">		<span class="keyword">int</span> p = partition(arr, left, right);</div><div class="line">		<span class="keyword">if</span> (p - <span class="number">1</span> &gt; left) &#123;</div><div class="line">			stack[len++] = left;</div><div class="line">			stack[len++] = p - <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (p + <span class="number">1</span> &lt; right) &#123;</div><div class="line">			stack[len++] = p + <span class="number">1</span>;</div><div class="line">			stack[len++] = right;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>把关键字<code>k_i</code>依次与有序区的关键字<code>k_i-1</code>、<code>k_i-2</code>、··· 、<code>k_1</code>比较<br>找到应该插入的位置，将<code>k_i</code>插入，后面的序列要往后移动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = arr[<span class="number">0</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</div><div class="line">		<span class="comment">// 若 arr[i] 不小于有序区的最后一个元素，直接扩大有序区</span></div><div class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123; </div><div class="line">			temp = arr[i];</div><div class="line">			<span class="keyword">int</span> j = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) &#123;</div><div class="line">				arr[j + <span class="number">1</span>] = arr[j--];</div><div class="line">			&#125;</div><div class="line">			arr[j + <span class="number">1</span>] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序当 n 较小时效率较高；当一组记录有序时，插入排序的算法复杂度可达到最优，即 O(n)。<br>希尔排序正是基于这两点对插入排序进行改进的。</p>
<p>希尔排序的基本思想：设置 t 个整数增量：<code>d_1</code>、<code>d_2</code>、···、<code>d_t</code>，其中<code>d_1 &lt; n</code>, <code>d_t=1</code><br>以<code>d_1</code>为增量，将所有距离为<code>d_1</code>的记录放到同一个组，可以得到<code>d_1</code>个组，在各组内进行直接插入排序；<br>然后取第二个增量<code>d_2</code>，重复上述的分组和排序，直至增量<code>d_t=1</code></p>
<p>设置增量序列时，要使得增量值没有除 1 之外的公因子，最后一个增量值必须为 1。<br>希尔排序的时间复杂度取决于增量序列的选取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// shellSort(origins, origins.length, new int[] &#123; 5, 3, 1 &#125;);</div><div class="line">public static void shellSort(int[] arr, int size, int[] d) &#123;</div><div class="line">	for (int k = 0; k &lt; d.length; k++) &#123;</div><div class="line">		int gap = d[k];</div><div class="line">		for (int j = 0; j &lt; gap; j++) &#123; // 对于增量值 gap，一共 gap 组，0~gap-1</div><div class="line">			for (int i = j + gap; i &lt; size; i++) &#123;</div><div class="line">				if (arr[i] &lt; arr[i - gap]) &#123; // 如果大于，不需要插入排序</div><div class="line">					int pivot = arr[i];</div><div class="line">					int t = i - gap;</div><div class="line">					while (t &gt;= 0 &amp;&amp; pivot &lt; arr[t]) &#123;</div><div class="line">						arr[t + gap] = arr[t];</div><div class="line">						t = t - gap;</div><div class="line">					&#125;</div><div class="line">					arr[t + gap] = pivot;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并的含义是：将两个或两个以上的有序表合并成一个新的有序表。<br>归并排序的思路是：<br>假设初始表含有 n 个记录，可看成是 n 个有序的子表，每个子表的长度为1，然后两两归并，<br>得到 n/2 个长度为 2 的有序子表，再两两归并，如此重复，直至得到长度为 n 的有序子表为止。</p>
<p>合并两个有序表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 将arr[low]~arr[center]与arr[center+1]~arr[right]合并成有序表</div><div class="line">public static void merge(int[] arr, int left, int center, int right) &#123;</div><div class="line">	int[] result = new int[right - left + 1];</div><div class="line">	int i = left, j = center + 1, k = 0;</div><div class="line">	while (i &lt;= center &amp;&amp; j &lt;= right) &#123;</div><div class="line">		if (arr[i] &lt; arr[j])</div><div class="line">			result[k++] = arr[i++];</div><div class="line">		else</div><div class="line">			result[k++] = arr[j++];</div><div class="line">	&#125;</div><div class="line">	while (i &lt;= center)</div><div class="line">		result[k++] = arr[i++];</div><div class="line">	while (j &lt;= right)</div><div class="line">		result[k++] = arr[j++];</div><div class="line">	System.arraycopy(result, 0, arr, left, right - left + 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一趟归并：<br>假设长度为<code>n</code>的待排序序列中，每个<strong>有序表</strong>的长度为 <code>step</code>，归并前共有<code>n/step</code>个子序列：<br><code>arr[0]~arr[step-1], arr[step]~arr[step*2-1], ···</code> ，一趟归并将相邻的一对有序表进行归并。<br>需要考虑三种情况：</p>
<ul>
<li>有序表的个数为偶数，且长度均为<code>step</code></li>
<li>有序表的个数为偶数，但最后一个有序表的长度小于<code>step</code></li>
<li>有序表的个数为奇数（轮空，不需要归并）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 子表的长度为 step，对数组进行一趟归并</div><div class="line">public static void mergePass(int[] arr, int step) &#123;</div><div class="line">	int length = arr.length;</div><div class="line">	int i = 0;</div><div class="line">	// 循环，归并长度为 step 的两个有序表</div><div class="line">	for (; i + step * 2 - 1 &lt; length; i += step * 2) &#123;</div><div class="line">		merge(arr, i, i + step - 1, i + step * 2 - 1);</div><div class="line">	&#125;</div><div class="line">	if (i + step &lt; length)</div><div class="line">		merge(arr, i, i + step - 1, length - 1);</div><div class="line">	// 注意: 若 i + step &gt;= length, 最后一个子表轮空，无需归并</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>归并排序时，有序表的初始长度为1，每趟归并后有序表长度增大一倍；<br>若干趟归并后，有序表的长度<code>&gt;=n</code>，排序结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void mergeSort(int[] arr, int size) &#123;</div><div class="line">	for (int i = 1; i &lt; size; i *= 2) &#123;</div><div class="line">		mergePass(arr, i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>算法思路：第一趟排序将待排序记录 <code>arr[0]~arr[n-1]</code>作为无序区，从中找出最小的记录并与无序区<br>第1个记录<code>arr[0]</code>交换，此时得到有序区为<code>arr[0]</code>，无序区为<code>arr[1]~arr[n-1]</code>。<br>第二趟排序从<code>arr[1]~arr[n-1]</code>选出最小的记录，与<code>arr[1]</code>交换。<br>重复上述过程…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void selectSort(int[] arr, int size) &#123;</div><div class="line">	for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">		int min = i;</div><div class="line">		for (int j = i + 1; j &lt; size; j++) &#123;</div><div class="line">			if (arr[j] &lt; arr[min])</div><div class="line">				min = j;</div><div class="line">		&#125;</div><div class="line">		if (min != i)</div><div class="line">			swap(arr, min, i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序需要建立最小堆，参见这篇文章 <a href="http://www.alijava.com/heap-sort/" target="_blank" rel="external">http://www.alijava.com/heap-sort/</a></p>
<h2 id="排序汇总"><a href="#排序汇总" class="headerlink" title="排序汇总"></a>排序汇总</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>快排</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>插入</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>希尔</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>归并</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>选择</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<hr>
<p>利用递归实现快速排序，需要O(logn)的辅助空间;<br>归并排序大多数实现方法是O(logn)的辅助空间，少数是 O(1);<br>常见的稳定的排序为：冒泡、插入、归并。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/02/sort-summary/" data-id="ciyyds56i001cbuxbcw1edimh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/10/03/javac-error/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          javac、javap命令行执行 java 程序的一点小坑
        
      </div>
    </a>
  
  
    <a href="/2016/09/22/heap-sort/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">经典排序之 堆排序（附两种建堆思路及代码）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MaterialDesign/">MaterialDesign</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/七牛/">七牛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令行/">命令行</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 18px;">Android</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MaterialDesign/" style="font-size: 10px;">MaterialDesign</a> <a href="/tags/Python/" style="font-size: 12px;">Python</a> <a href="/tags/七牛/" style="font-size: 10px;">七牛</a> <a href="/tags/命令行/" style="font-size: 10px;">命令行</a> <a href="/tags/工具/" style="font-size: 14px;">工具</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/面试/" style="font-size: 16px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/04/hexo-tips/">从 CSDN 博客迁移到个人 Hexo 站点的一点坑</a>
          </li>
        
          <li>
            <a href="/2017/02/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/11/25/campus-interview/">2017互联网校园招聘的一些面试题</a>
          </li>
        
          <li>
            <a href="/2016/10/03/javac-error/">javac、javap命令行执行 java 程序的一点小坑</a>
          </li>
        
          <li>
            <a href="/2016/10/02/sort-summary/">经典排序算法总结--冒泡、快排、插入、希尔、归并、选择</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>